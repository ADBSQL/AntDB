--
-- TYPE_SANITY
-- Sanity checks for common errors in making type-related system tables:
-- pg_type, pg_class, pg_attribute, pg_range.
--
-- None of the SELECTs here should ever find any matching entries,
-- so the expected output is easy to maintain ;-).
-- A test failure indicates someone messed up an entry in the system tables.
--
-- NB: we assume the oidjoins test will have caught any dangling links,
-- that is OID or REGPROC fields that are not zero and do not match some
-- row in the linked-to table.  However, if we want to enforce that a link
-- field can't be 0, we have to check it here.
-- **************** pg_type ****************
-- Look for illegal values in pg_type fields.
SELECT p1.oid, p1.typname
FROM pg_type as p1
WHERE p1.typnamespace = 0 OR
    (p1.typlen <= 0 AND p1.typlen != -1 AND p1.typlen != -2) OR
    (p1.typtype not in ('b', 'c', 'd', 'e', 'p', 'r')) OR
    NOT p1.typisdefined OR
    (p1.typalign not in ('c', 's', 'i', 'd')) OR
    (p1.typstorage not in ('p', 'x', 'e', 'm'));
 oid | typname 
-----+---------
(0 rows)

-- Look for "pass by value" types that can't be passed by value.
SELECT p1.oid, p1.typname
FROM pg_type as p1
WHERE p1.typbyval AND
    (p1.typlen != 1 OR p1.typalign != 'c') AND
    (p1.typlen != 2 OR p1.typalign != 's') AND
    (p1.typlen != 4 OR p1.typalign != 'i') AND
    (p1.typlen != 8 OR p1.typalign != 'd');
 oid | typname 
-----+---------
(0 rows)

-- Look for "toastable" types that aren't varlena.
SELECT p1.oid, p1.typname
FROM pg_type as p1
WHERE p1.typstorage != 'p' AND
    (p1.typbyval OR p1.typlen != -1);
 oid | typname 
-----+---------
(0 rows)

-- Look for complex types that do not have a typrelid entry,
-- or basic types that do.
SELECT p1.oid, p1.typname
FROM pg_type as p1
WHERE (p1.typtype = 'c' AND p1.typrelid = 0) OR
    (p1.typtype != 'c' AND p1.typrelid != 0);
 oid | typname 
-----+---------
(0 rows)

-- Look for types that should have an array type according to their typtype,
-- but don't.  We exclude composites here because we have not bothered to
-- make array types corresponding to the system catalogs' rowtypes.
-- NOTE: as of v10, this check finds pg_node_tree, pg_ndistinct, smgr.
SELECT p1.oid, p1.typname
FROM pg_type as p1
WHERE p1.typtype not in ('c','d','p') AND p1.typname NOT LIKE E'\\_%'
    AND NOT EXISTS
    (SELECT 1 FROM pg_type as p2
     WHERE p2.typname = ('_' || p1.typname)::name AND
           p2.typelem = p1.oid and p1.typarray = p2.oid);
 oid  |     typname     
------+-----------------
  194 | pg_node_tree
 3361 | pg_ndistinct
 3402 | pg_dependencies
 5017 | pg_mcv_list
(4 rows)

-- Make sure typarray points to a varlena array type of our own base
SELECT p1.oid, p1.typname as basetype, p2.typname as arraytype,
       p2.typelem, p2.typlen
FROM   pg_type p1 LEFT JOIN pg_type p2 ON (p1.typarray = p2.oid)
WHERE  p1.typarray <> 0 AND
       (p2.oid IS NULL OR p2.typelem <> p1.oid OR p2.typlen <> -1);
 oid | basetype | arraytype | typelem | typlen 
-----+----------+-----------+---------+--------
(0 rows)

-- Look for range types that do not have a pg_range entry
SELECT p1.oid, p1.typname
FROM pg_type as p1
WHERE p1.typtype = 'r' AND
   NOT EXISTS(SELECT 1 FROM pg_range r WHERE rngtypid = p1.oid);
 oid | typname 
-----+---------
(0 rows)

-- Look for range types whose typalign isn't sufficient
SELECT p1.oid, p1.typname, p1.typalign, p2.typname, p2.typalign
FROM pg_type as p1
     LEFT JOIN pg_range as r ON rngtypid = p1.oid
     LEFT JOIN pg_type as p2 ON rngsubtype = p2.oid
WHERE p1.typtype = 'r' AND
    (p1.typalign != (CASE WHEN p2.typalign = 'd' THEN 'd'::"char"
                          ELSE 'i'::"char" END)
     OR p2.oid IS NULL);
 oid | typname | typalign | typname | typalign 
-----+---------+----------+---------+----------
(0 rows)

-- Text conversion routines must be provided.
SELECT p1.oid, p1.typname
FROM pg_type as p1
WHERE (p1.typinput = 0 OR p1.typoutput = 0);
 oid | typname 
-----+---------
(0 rows)

-- Check for bogus typinput routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typinput = p2.oid AND NOT
    ((p2.pronargs = 1 AND p2.proargtypes[0] = 'cstring'::regtype) OR
     (p2.pronargs = 2 AND p2.proargtypes[0] = 'cstring'::regtype AND
      p2.proargtypes[1] = 'oid'::regtype) OR
     (p2.pronargs = 3 AND p2.proargtypes[0] = 'cstring'::regtype AND
      p2.proargtypes[1] = 'oid'::regtype AND
      p2.proargtypes[2] = 'int4'::regtype));
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Check for type of the variadic array parameter's elements.
-- provariadic should be ANYOID if the type of the last element is ANYOID,
-- ANYELEMENTOID if the type of the last element is ANYARRAYOID, and otherwise
-- the element type corresponding to the array type.
SELECT oid::regprocedure, provariadic::regtype, proargtypes::regtype[]
FROM pg_proc
WHERE provariadic != 0
AND case proargtypes[array_length(proargtypes, 1)-1]
    WHEN 2276 THEN 2276 -- any -> any
	WHEN 2277 THEN 2283 -- anyarray -> anyelement
	ELSE (SELECT t.oid
		  FROM pg_type t
		  WHERE t.typarray = proargtypes[array_length(proargtypes, 1)-1])
	END  != provariadic;
 oid | provariadic | proargtypes 
-----+-------------+-------------
(0 rows)

-- Check that all and only those functions with a variadic type have
-- a variadic argument.
SELECT oid::regprocedure, proargmodes, provariadic
FROM pg_proc
WHERE (proargmodes IS NOT NULL AND 'v' = any(proargmodes))
    IS DISTINCT FROM
    (provariadic != 0);
 oid | proargmodes | provariadic 
-----+-------------+-------------
(0 rows)

-- As of 8.0, this check finds refcursor, which is borrowing
-- other types' I/O routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typinput = p2.oid AND p1.typtype in ('b', 'p') AND NOT
    (p1.typelem != 0 AND p1.typlen < 0) AND NOT
    (p2.prorettype = p1.oid AND NOT p2.proretset)
ORDER BY 1;
 oid  |  typname  | oid  |  proname   
------+-----------+------+------------
 1790 | refcursor |   46 | textin
 9129 | varchar2  | 9132 | varchar2in
(2 rows)

-- Varlena array types will point to array_in
-- Exception as of 8.1: int2vector and oidvector have their own I/O routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typinput = p2.oid AND
    (p1.typelem != 0 AND p1.typlen < 0) AND NOT
    (p2.oid = 'array_in'::regproc)
ORDER BY 1;
 oid |  typname   | oid |   proname    
-----+------------+-----+--------------
  22 | int2vector |  40 | int2vectorin
  30 | oidvector  |  54 | oidvectorin
(2 rows)

-- typinput routines should not be volatile
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typinput = p2.oid AND p2.provolatile NOT IN ('i', 's');
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Composites, domains, enums, ranges should all use the same input routines
SELECT DISTINCT typtype, typinput
FROM pg_type AS p1
WHERE p1.typtype not in ('b', 'p')
ORDER BY 1;
 typtype |     typinput      
---------+-------------------
 c       | record_in
 d       | oracle.ora_raw_in
 d       | domain_in
 e       | enum_in
 r       | range_in
(5 rows)

-- Check for bogus typoutput routines
-- As of 8.0, this check finds refcursor, which is borrowing
-- other types' I/O routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typoutput = p2.oid AND p1.typtype in ('b', 'p') AND NOT
    (p2.pronargs = 1 AND
     (p2.proargtypes[0] = p1.oid OR
      (p2.oid = 'array_out'::regproc AND
       p1.typelem != 0 AND p1.typlen = -1)))
ORDER BY 1;
 oid  |  typname  | oid  |   proname   
------+-----------+------+-------------
 1790 | refcursor |   47 | textout
 9129 | varchar2  | 9133 | varchar2out
(2 rows)

SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typoutput = p2.oid AND NOT
    (p2.prorettype = 'cstring'::regtype AND NOT p2.proretset);
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- typoutput routines should not be volatile
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typoutput = p2.oid AND p2.provolatile NOT IN ('i', 's');
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Composites, enums, ranges should all use the same output routines
SELECT DISTINCT typtype, typoutput
FROM pg_type AS p1
WHERE p1.typtype not in ('b', 'd', 'p')
ORDER BY 1;
 typtype | typoutput  
---------+------------
 c       | record_out
 e       | enum_out
 r       | range_out
(3 rows)

-- Domains should have same typoutput as their base types
SELECT p1.oid, p1.typname, p2.oid, p2.typname
FROM pg_type AS p1 LEFT JOIN pg_type AS p2 ON p1.typbasetype = p2.oid
WHERE p1.typtype = 'd' AND p1.typoutput IS DISTINCT FROM p2.typoutput;
 oid  | typname | oid | typname 
------+---------+-----+---------
 8903 | raw     |  17 | bytea
(1 row)

-- Check for bogus typreceive routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typreceive = p2.oid AND NOT
    ((p2.pronargs = 1 AND p2.proargtypes[0] = 'internal'::regtype) OR
     (p2.pronargs = 2 AND p2.proargtypes[0] = 'internal'::regtype AND
      p2.proargtypes[1] = 'oid'::regtype) OR
     (p2.pronargs = 3 AND p2.proargtypes[0] = 'internal'::regtype AND
      p2.proargtypes[1] = 'oid'::regtype AND
      p2.proargtypes[2] = 'int4'::regtype));
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- As of 7.4, this check finds refcursor, which is borrowing
-- other types' I/O routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typreceive = p2.oid AND p1.typtype in ('b', 'p') AND NOT
    (p1.typelem != 0 AND p1.typlen < 0) AND NOT
    (p2.prorettype = p1.oid AND NOT p2.proretset)
ORDER BY 1;
 oid  |  typname  | oid  |   proname    
------+-----------+------+--------------
 1790 | refcursor | 2414 | textrecv
 9129 | varchar2  | 9134 | varchar2recv
(2 rows)

-- Varlena array types will point to array_recv
-- Exception as of 8.1: int2vector and oidvector have their own I/O routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typreceive = p2.oid AND
    (p1.typelem != 0 AND p1.typlen < 0) AND NOT
    (p2.oid = 'array_recv'::regproc)
ORDER BY 1;
 oid |  typname   | oid  |    proname     
-----+------------+------+----------------
  22 | int2vector | 2410 | int2vectorrecv
  30 | oidvector  | 2420 | oidvectorrecv
(2 rows)

-- Suspicious if typreceive doesn't take same number of args as typinput
SELECT p1.oid, p1.typname, p2.oid, p2.proname, p3.oid, p3.proname
FROM pg_type AS p1, pg_proc AS p2, pg_proc AS p3
WHERE p1.typinput = p2.oid AND p1.typreceive = p3.oid AND
    p2.pronargs != p3.pronargs;
 oid | typname | oid | proname | oid | proname 
-----+---------+-----+---------+-----+---------
(0 rows)

-- typreceive routines should not be volatile
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typreceive = p2.oid AND p2.provolatile NOT IN ('i', 's');
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Composites, domains, enums, ranges should all use the same receive routines
SELECT DISTINCT typtype, typreceive
FROM pg_type AS p1
WHERE p1.typtype not in ('b', 'p')
ORDER BY 1;
 typtype | typreceive  
---------+-------------
 c       | record_recv
 d       | bytearecv
 d       | domain_recv
 e       | enum_recv
 r       | range_recv
(5 rows)

-- Check for bogus typsend routines
-- As of 7.4, this check finds refcursor, which is borrowing
-- other types' I/O routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typsend = p2.oid AND p1.typtype in ('b', 'p') AND NOT
    (p2.pronargs = 1 AND
     (p2.proargtypes[0] = p1.oid OR
      (p2.oid = 'array_send'::regproc AND
       p1.typelem != 0 AND p1.typlen = -1)))
ORDER BY 1;
 oid  |  typname  | oid  |   proname   
------+-----------+------+-------------
 1790 | refcursor | 2415 | textsend
 9025 | nvarchar2 | 2433 | varcharsend
 9129 | varchar2  | 2433 | varcharsend
(3 rows)

SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typsend = p2.oid AND NOT
    (p2.prorettype = 'bytea'::regtype AND NOT p2.proretset);
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- typsend routines should not be volatile
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typsend = p2.oid AND p2.provolatile NOT IN ('i', 's');
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Composites, enums, ranges should all use the same send routines
SELECT DISTINCT typtype, typsend
FROM pg_type AS p1
WHERE p1.typtype not in ('b', 'd', 'p')
ORDER BY 1;
 typtype |   typsend   
---------+-------------
 c       | record_send
 e       | enum_send
 r       | range_send
(3 rows)

-- Domains should have same typsend as their base types
SELECT p1.oid, p1.typname, p2.oid, p2.typname
FROM pg_type AS p1 LEFT JOIN pg_type AS p2 ON p1.typbasetype = p2.oid
WHERE p1.typtype = 'd' AND p1.typsend IS DISTINCT FROM p2.typsend;
 oid | typname | oid | typname 
-----+---------+-----+---------
(0 rows)

-- Check for bogus typmodin routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typmodin = p2.oid AND NOT
    (p2.pronargs = 1 AND
     p2.proargtypes[0] = 'cstring[]'::regtype AND
     p2.prorettype = 'int4'::regtype AND NOT p2.proretset);
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- typmodin routines should not be volatile
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typmodin = p2.oid AND p2.provolatile NOT IN ('i', 's');
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Check for bogus typmodout routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typmodout = p2.oid AND NOT
    (p2.pronargs = 1 AND
     p2.proargtypes[0] = 'int4'::regtype AND
     p2.prorettype = 'cstring'::regtype AND NOT p2.proretset);
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- typmodout routines should not be volatile
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typmodout = p2.oid AND p2.provolatile NOT IN ('i', 's');
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Array types should have same typmodin/out as their element types
SELECT p1.oid, p1.typname, p2.oid, p2.typname
FROM pg_type AS p1, pg_type AS p2
WHERE p1.typelem = p2.oid AND NOT
    (p1.typmodin = p2.typmodin AND p1.typmodout = p2.typmodout);
 oid | typname | oid | typname 
-----+---------+-----+---------
(0 rows)

-- Array types should have same typdelim as their element types
SELECT p1.oid, p1.typname, p2.oid, p2.typname
FROM pg_type AS p1, pg_type AS p2
WHERE p1.typarray = p2.oid AND NOT (p1.typdelim = p2.typdelim);
 oid | typname | oid | typname 
-----+---------+-----+---------
(0 rows)

-- Look for array types whose typalign isn't sufficient
SELECT p1.oid, p1.typname, p1.typalign, p2.typname, p2.typalign
FROM pg_type AS p1, pg_type AS p2
WHERE p1.typarray = p2.oid AND
    p2.typalign != (CASE WHEN p1.typalign = 'd' THEN 'd'::"char"
                         ELSE 'i'::"char" END);
 oid  | typname | typalign | typname | typalign 
------+---------+----------+---------+----------
 9009 | date    | d        | _date   | i
(1 row)

-- Check for bogus typanalyze routines
SELECT p1.oid, p1.typname, p2.oid, p2.proname
FROM pg_type AS p1, pg_proc AS p2
WHERE p1.typanalyze = p2.oid AND NOT
    (p2.pronargs = 1 AND
     p2.proargtypes[0] = 'internal'::regtype AND
     p2.prorettype = 'bool'::regtype AND NOT p2.proretset);
 oid | typname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- there does not seem to be a reason to care about volatility of typanalyze
-- domains inherit their base type's typanalyze
SELECT d.oid, d.typname, d.typanalyze, t.oid, t.typname, t.typanalyze
FROM pg_type d JOIN pg_type t ON d.typbasetype = t.oid
WHERE d.typanalyze != t.typanalyze;
 oid | typname | typanalyze | oid | typname | typanalyze 
-----+---------+------------+-----+---------+------------
(0 rows)

-- range_typanalyze should be used for all and only range types
-- (but exclude domains, which we checked above)
SELECT t.oid, t.typname, t.typanalyze
FROM pg_type t LEFT JOIN pg_range r on t.oid = r.rngtypid
WHERE t.typbasetype = 0 AND
    (t.typanalyze = 'range_typanalyze'::regproc) != (r.rngtypid IS NOT NULL);
 oid | typname | typanalyze 
-----+---------+------------
(0 rows)

-- array_typanalyze should be used for all and only array types
-- (but exclude domains, which we checked above)
-- As of 9.2 this finds int2vector and oidvector, which are weird anyway
SELECT t.oid, t.typname, t.typanalyze
FROM pg_type t
WHERE t.typbasetype = 0 AND
    (t.typanalyze = 'array_typanalyze'::regproc) !=
    (typelem != 0 AND typlen < 0)
ORDER BY 1;
 oid |  typname   | typanalyze 
-----+------------+------------
  22 | int2vector | -
  30 | oidvector  | -
(2 rows)

-- **************** pg_class ****************
-- Look for illegal values in pg_class fields
SELECT p1.oid, p1.relname
FROM pg_class as p1
WHERE relkind NOT IN ('r', 'i', 'S', 't', 'v', 'm', 'c', 'f', 'p') OR
    relpersistence NOT IN ('p', 'u', 't') OR
    relreplident NOT IN ('d', 'n', 'f', 'i');
 oid | relname 
-----+---------
(0 rows)

-- All tables and indexes should have an access method.
SELECT p1.oid, p1.relname
FROM pg_class as p1
WHERE p1.relkind NOT IN ('S', 'v', 'f', 'c') and
    p1.relam = 0;
  oid  |   relname    
-------+--------------
 18551 | mlparted
 18554 | mlparted1
 18619 | mlparted_def
(3 rows)

-- Conversely, sequences, views, types shouldn't have them
SELECT p1.oid, p1.relname
FROM pg_class as p1
WHERE p1.relkind IN ('S', 'v', 'f', 'c') and
    p1.relam != 0;
 oid | relname 
-----+---------
(0 rows)

-- Indexes should have AMs of type 'i'
SELECT pc.oid, pc.relname, pa.amname, pa.amtype
FROM pg_class as pc JOIN pg_am AS pa ON (pc.relam = pa.oid)
WHERE pc.relkind IN ('i') and
    pa.amtype != 'i';
 oid | relname | amname | amtype 
-----+---------+--------+--------
(0 rows)

-- Tables, matviews etc should have AMs of type 't'
SELECT pc.oid, pc.relname, pa.amname, pa.amtype
FROM pg_class as pc JOIN pg_am AS pa ON (pc.relam = pa.oid)
WHERE pc.relkind IN ('r', 't', 'm') and
    pa.amtype != 't';
 oid | relname | amname | amtype 
-----+---------+--------+--------
(0 rows)

-- **************** pg_attribute ****************
-- Look for illegal values in pg_attribute fields
SELECT p1.attrelid, p1.attname
FROM pg_attribute as p1
WHERE p1.attrelid = 0 OR p1.atttypid = 0 OR p1.attnum = 0 OR
    p1.attcacheoff != -1 OR p1.attinhcount < 0 OR
    (p1.attinhcount = 0 AND NOT p1.attislocal);
 attrelid |           attname            
----------+------------------------------
    18557 | ........pg.dropped.2........
    18557 | ........pg.dropped.3........
    18581 | ........pg.dropped.1........
    18557 | ........pg.dropped.7........
    18572 | ........pg.dropped.5........
    18554 | ........pg.dropped.5........
    18575 | ........pg.dropped.5........
    18578 | ........pg.dropped.5........
    18581 | ........pg.dropped.6........
    18622 | ........pg.dropped.5........
    18628 | ........pg.dropped.5........
    18634 | ........pg.dropped.5........
    18619 | ........pg.dropped.5........
    18551 | ........pg.dropped.5........
    18557 | ........pg.dropped.6........
    18572 | ........pg.dropped.4........
    18554 | ........pg.dropped.4........
    18575 | ........pg.dropped.4........
    18578 | ........pg.dropped.4........
    18581 | ........pg.dropped.5........
    18622 | ........pg.dropped.4........
    18628 | ........pg.dropped.4........
    18634 | ........pg.dropped.4........
    18619 | ........pg.dropped.4........
    18551 | ........pg.dropped.4........
    18557 | ........pg.dropped.9........
    18572 | ........pg.dropped.7........
    18554 | ........pg.dropped.7........
    18575 | ........pg.dropped.7........
    18578 | ........pg.dropped.7........
    18551 | ........pg.dropped.7........
    18557 | ........pg.dropped.8........
    18572 | ........pg.dropped.6........
    18554 | ........pg.dropped.6........
    18575 | ........pg.dropped.6........
    18578 | ........pg.dropped.6........
    18581 | ........pg.dropped.7........
    18622 | ........pg.dropped.6........
    18628 | ........pg.dropped.6........
    18634 | ........pg.dropped.6........
    18619 | ........pg.dropped.6........
    18551 | ........pg.dropped.6........
    18581 | ........pg.dropped.8........
    18622 | ........pg.dropped.7........
    18628 | ........pg.dropped.7........
    18634 | ........pg.dropped.7........
    18619 | ........pg.dropped.7........
(47 rows)

-- Cross-check attnum against parent relation
SELECT p1.attrelid, p1.attname, p2.oid, p2.relname
FROM pg_attribute AS p1, pg_class AS p2
WHERE p1.attrelid = p2.oid AND p1.attnum > p2.relnatts;
 attrelid | attname | oid | relname 
----------+---------+-----+---------
(0 rows)

-- Detect missing pg_attribute entries: should have as many non-system
-- attributes as parent relation expects
SELECT p1.oid, p1.relname
FROM pg_class AS p1
WHERE p1.relnatts != (SELECT count(*) FROM pg_attribute AS p2
                      WHERE p2.attrelid = p1.oid AND p2.attnum > 0);
 oid | relname 
-----+---------
(0 rows)

-- Cross-check against pg_type entry
-- NOTE: we allow attstorage to be 'plain' even when typstorage is not;
-- this is mainly for toast tables.
SELECT p1.attrelid, p1.attname, p2.oid, p2.typname
FROM pg_attribute AS p1, pg_type AS p2
WHERE p1.atttypid = p2.oid AND
    (p1.attlen != p2.typlen OR
     p1.attalign != p2.typalign OR
     p1.attbyval != p2.typbyval OR
     (p1.attstorage != p2.typstorage AND p1.attstorage != 'p'));
 attrelid | attname | oid  | typname 
----------+---------+------+---------
     2604 | rowid   | 9122 | rowid
     2606 | rowid   | 9122 | rowid
     2611 | rowid   | 9122 | rowid
     2610 | rowid   | 9122 | rowid
     2617 | rowid   | 9122 | rowid
     2753 | rowid   | 9122 | rowid
     2616 | rowid   | 9122 | rowid
     2601 | rowid   | 9122 | rowid
     2602 | rowid   | 9122 | rowid
     2603 | rowid   | 9122 | rowid
     2612 | rowid   | 9122 | rowid
     2995 | rowid   | 9122 | rowid
     2613 | rowid   | 9122 | rowid
     2600 | rowid   | 9122 | rowid
     3381 | rowid   | 9122 | rowid
     3429 | rowid   | 9122 | rowid
     2619 | rowid   | 9122 | rowid
     2618 | rowid   | 9122 | rowid
     2620 | rowid   | 9122 | rowid
     3466 | rowid   | 9122 | rowid
     2609 | rowid   | 9122 | rowid
     2605 | rowid   | 9122 | rowid
     3501 | rowid   | 9122 | rowid
     2615 | rowid   | 9122 | rowid
     2607 | rowid   | 9122 | rowid
     2608 | rowid   | 9122 | rowid
     1262 | rowid   | 9122 | rowid
     2964 | rowid   | 9122 | rowid
     1213 | rowid   | 9122 | rowid
     1136 | rowid   | 9122 | rowid
     1260 | rowid   | 9122 | rowid
     1261 | rowid   | 9122 | rowid
     1214 | rowid   | 9122 | rowid
     2396 | rowid   | 9122 | rowid
     3602 | rowid   | 9122 | rowid
     3603 | rowid   | 9122 | rowid
     3600 | rowid   | 9122 | rowid
     3601 | rowid   | 9122 | rowid
     3764 | rowid   | 9122 | rowid
     3079 | rowid   | 9122 | rowid
     2328 | rowid   | 9122 | rowid
     1417 | rowid   | 9122 | rowid
     1418 | rowid   | 9122 | rowid
     3118 | rowid   | 9122 | rowid
     3256 | rowid   | 9122 | rowid
     6000 | rowid   | 9122 | rowid
      826 | rowid   | 9122 | rowid
     3394 | rowid   | 9122 | rowid
     3596 | rowid   | 9122 | rowid
     3592 | rowid   | 9122 | rowid
     3456 | rowid   | 9122 | rowid
     3350 | rowid   | 9122 | rowid
     3541 | rowid   | 9122 | rowid
     3576 | rowid   | 9122 | rowid
     2224 | rowid   | 9122 | rowid
     6104 | rowid   | 9122 | rowid
     6106 | rowid   | 9122 | rowid
     6100 | rowid   | 9122 | rowid
     6102 | rowid   | 9122 | rowid
     9121 | rowid   | 9122 | rowid
     6116 | rowid   | 9122 | rowid
     4159 | rowid   | 9122 | rowid
     2830 | rowid   | 9122 | rowid
     4161 | rowid   | 9122 | rowid
     2832 | rowid   | 9122 | rowid
     4143 | rowid   | 9122 | rowid
     2834 | rowid   | 9122 | rowid
     4145 | rowid   | 9122 | rowid
     4147 | rowid   | 9122 | rowid
     4149 | rowid   | 9122 | rowid
     4151 | rowid   | 9122 | rowid
     4153 | rowid   | 9122 | rowid
     4155 | rowid   | 9122 | rowid
     4157 | rowid   | 9122 | rowid
     4163 | rowid   | 9122 | rowid
     4165 | rowid   | 9122 | rowid
     4167 | rowid   | 9122 | rowid
     2836 | rowid   | 9122 | rowid
     2838 | rowid   | 9122 | rowid
     3598 | rowid   | 9122 | rowid
     2840 | rowid   | 9122 | rowid
     3439 | rowid   | 9122 | rowid
     3430 | rowid   | 9122 | rowid
     2336 | rowid   | 9122 | rowid
     4169 | rowid   | 9122 | rowid
     4171 | rowid   | 9122 | rowid
     4173 | rowid   | 9122 | rowid
     4175 | rowid   | 9122 | rowid
     4177 | rowid   | 9122 | rowid
     2966 | rowid   | 9122 | rowid
     4179 | rowid   | 9122 | rowid
     4181 | rowid   | 9122 | rowid
     2846 | rowid   | 9122 | rowid
     4060 | rowid   | 9122 | rowid
     4183 | rowid   | 9122 | rowid
     4185 | rowid   | 9122 | rowid
    16424 | rowid   | 9122 | rowid
    16427 | rowid   | 9122 | rowid
    16430 | rowid   | 9122 | rowid
    13431 | rowid   | 9122 | rowid
    13433 | rowid   | 9122 | rowid
    13436 | rowid   | 9122 | rowid
    13438 | rowid   | 9122 | rowid
    13441 | rowid   | 9122 | rowid
    13443 | rowid   | 9122 | rowid
    13446 | rowid   | 9122 | rowid
    13448 | rowid   | 9122 | rowid
    13451 | rowid   | 9122 | rowid
    13453 | rowid   | 9122 | rowid
    13456 | rowid   | 9122 | rowid
    13458 | rowid   | 9122 | rowid
    13461 | rowid   | 9122 | rowid
    13463 | rowid   | 9122 | rowid
    16433 | rowid   | 9122 | rowid
    16436 | rowid   | 9122 | rowid
    16439 | rowid   | 9122 | rowid
    16442 | rowid   | 9122 | rowid
    16445 | rowid   | 9122 | rowid
    16448 | rowid   | 9122 | rowid
    16451 | rowid   | 9122 | rowid
    16454 | rowid   | 9122 | rowid
    16457 | rowid   | 9122 | rowid
    16460 | rowid   | 9122 | rowid
    16463 | rowid   | 9122 | rowid
    16466 | rowid   | 9122 | rowid
    16469 | rowid   | 9122 | rowid
    16472 | rowid   | 9122 | rowid
    16475 | rowid   | 9122 | rowid
    16478 | rowid   | 9122 | rowid
    16481 | rowid   | 9122 | rowid
    16484 | rowid   | 9122 | rowid
    16487 | rowid   | 9122 | rowid
    16490 | rowid   | 9122 | rowid
    16493 | rowid   | 9122 | rowid
    16496 | rowid   | 9122 | rowid
    16499 | rowid   | 9122 | rowid
    16502 | rowid   | 9122 | rowid
    16505 | rowid   | 9122 | rowid
    16508 | rowid   | 9122 | rowid
    16511 | rowid   | 9122 | rowid
    16514 | rowid   | 9122 | rowid
    16517 | rowid   | 9122 | rowid
    16520 | rowid   | 9122 | rowid
    16523 | rowid   | 9122 | rowid
    16526 | rowid   | 9122 | rowid
    16529 | rowid   | 9122 | rowid
    16532 | rowid   | 9122 | rowid
    16535 | rowid   | 9122 | rowid
    16538 | rowid   | 9122 | rowid
    16541 | rowid   | 9122 | rowid
    16544 | rowid   | 9122 | rowid
    16547 | rowid   | 9122 | rowid
    16550 | rowid   | 9122 | rowid
    16553 | rowid   | 9122 | rowid
    16556 | rowid   | 9122 | rowid
    16559 | rowid   | 9122 | rowid
    16562 | rowid   | 9122 | rowid
    16565 | rowid   | 9122 | rowid
    16568 | rowid   | 9122 | rowid
    16571 | rowid   | 9122 | rowid
    16574 | rowid   | 9122 | rowid
    16577 | rowid   | 9122 | rowid
    16580 | rowid   | 9122 | rowid
    16583 | rowid   | 9122 | rowid
    16586 | rowid   | 9122 | rowid
    16632 | rowid   | 9122 | rowid
    16635 | rowid   | 9122 | rowid
    17309 | rowid   | 9122 | rowid
    17312 | rowid   | 9122 | rowid
    17420 | rowid   | 9122 | rowid
    17423 | rowid   | 9122 | rowid
    17637 | rowid   | 9122 | rowid
    18551 | rowid   | 9122 | rowid
    18554 | rowid   | 9122 | rowid
    18557 | rowid   | 9122 | rowid
    18572 | rowid   | 9122 | rowid
    18575 | rowid   | 9122 | rowid
    18578 | rowid   | 9122 | rowid
    18581 | rowid   | 9122 | rowid
    18584 | rowid   | 9122 | rowid
    18587 | rowid   | 9122 | rowid
    18590 | rowid   | 9122 | rowid
    18593 | rowid   | 9122 | rowid
    18596 | rowid   | 9122 | rowid
    18619 | rowid   | 9122 | rowid
    18622 | rowid   | 9122 | rowid
    18625 | rowid   | 9122 | rowid
    18628 | rowid   | 9122 | rowid
    18631 | rowid   | 9122 | rowid
    18634 | rowid   | 9122 | rowid
    18637 | rowid   | 9122 | rowid
    20250 | rowid   | 9122 | rowid
    20253 | rowid   | 9122 | rowid
    20261 | rowid   | 9122 | rowid
    20263 | rowid   | 9122 | rowid
    20266 | rowid   | 9122 | rowid
    20275 | rowid   | 9122 | rowid
    20274 | rowid   | 9122 | rowid
    20281 | rowid   | 9122 | rowid
    20283 | rowid   | 9122 | rowid
    20317 | rowid   | 9122 | rowid
    20332 | rowid   | 9122 | rowid
    20343 | rowid   | 9122 | rowid
    20356 | rowid   | 9122 | rowid
    20373 | rowid   | 9122 | rowid
    20349 | rowid   | 9122 | rowid
    20364 | rowid   | 9122 | rowid
    20377 | rowid   | 9122 | rowid
    20380 | rowid   | 9122 | rowid
    20383 | rowid   | 9122 | rowid
    20391 | rowid   | 9122 | rowid
    20395 | rowid   | 9122 | rowid
    20406 | rowid   | 9122 | rowid
    20600 | rowid   | 9122 | rowid
    20603 | rowid   | 9122 | rowid
    20517 | rowid   | 9122 | rowid
    20521 | rowid   | 9122 | rowid
    20551 | rowid   | 9122 | rowid
    20509 | rowid   | 9122 | rowid
    20555 | rowid   | 9122 | rowid
    20607 | rowid   | 9122 | rowid
    20610 | rowid   | 9122 | rowid
    20619 | rowid   | 9122 | rowid
    20622 | rowid   | 9122 | rowid
    20685 | rowid   | 9122 | rowid
    20688 | rowid   | 9122 | rowid
    20691 | rowid   | 9122 | rowid
    20692 | rowid   | 9122 | rowid
    20693 | rowid   | 9122 | rowid
    20699 | rowid   | 9122 | rowid
    20706 | rowid   | 9122 | rowid
    20712 | rowid   | 9122 | rowid
    20709 | rowid   | 9122 | rowid
    20714 | rowid   | 9122 | rowid
    20715 | rowid   | 9122 | rowid
    20717 | rowid   | 9122 | rowid
    20719 | rowid   | 9122 | rowid
    20734 | rowid   | 9122 | rowid
    20728 | rowid   | 9122 | rowid
    20743 | rowid   | 9122 | rowid
    20733 | rowid   | 9122 | rowid
    20748 | rowid   | 9122 | rowid
    20751 | rowid   | 9122 | rowid
    20784 | rowid   | 9122 | rowid
(244 rows)

-- **************** pg_range ****************
-- Look for illegal values in pg_range fields.
SELECT p1.rngtypid, p1.rngsubtype
FROM pg_range as p1
WHERE p1.rngtypid = 0 OR p1.rngsubtype = 0 OR p1.rngsubopc = 0;
 rngtypid | rngsubtype 
----------+------------
(0 rows)

-- rngcollation should be specified iff subtype is collatable
SELECT p1.rngtypid, p1.rngsubtype, p1.rngcollation, t.typcollation
FROM pg_range p1 JOIN pg_type t ON t.oid = p1.rngsubtype
WHERE (rngcollation = 0) != (typcollation = 0);
 rngtypid | rngsubtype | rngcollation | typcollation 
----------+------------+--------------+--------------
(0 rows)

-- opclass had better be a btree opclass accepting the subtype.
-- We must allow anyarray matches, cf opr_sanity's binary_coercible()
SELECT p1.rngtypid, p1.rngsubtype, o.opcmethod, o.opcname
FROM pg_range p1 JOIN pg_opclass o ON o.oid = p1.rngsubopc
WHERE o.opcmethod != 403 OR
    ((o.opcintype != p1.rngsubtype) AND NOT
     (o.opcintype = 'pg_catalog.anyarray'::regtype AND
      EXISTS(select 1 from pg_catalog.pg_type where
             oid = p1.rngsubtype and typelem != 0 and typlen = -1)));
 rngtypid | rngsubtype | opcmethod | opcname 
----------+------------+-----------+---------
(0 rows)

-- canonical function, if any, had better match the range type
SELECT p1.rngtypid, p1.rngsubtype, p.proname
FROM pg_range p1 JOIN pg_proc p ON p.oid = p1.rngcanonical
WHERE pronargs != 1 OR proargtypes[0] != rngtypid OR prorettype != rngtypid;
 rngtypid | rngsubtype | proname 
----------+------------+---------
(0 rows)

-- subdiff function, if any, had better match the subtype
SELECT p1.rngtypid, p1.rngsubtype, p.proname
FROM pg_range p1 JOIN pg_proc p ON p.oid = p1.rngsubdiff
WHERE pronargs != 2
    OR proargtypes[0] != rngsubtype OR proargtypes[1] != rngsubtype
    OR prorettype != 'pg_catalog.float8'::regtype;
 rngtypid | rngsubtype | proname 
----------+------------+---------
(0 rows)

